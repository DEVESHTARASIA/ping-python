#!/usr/bin/python -u

# Ping1D.py
# A device API for the Blue Robotics Ping1D echosounder

#~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!
# THIS IS AN AUTOGENERATED FILE
# DO NOT EDIT
#~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!~!

from Ping import PingMessage
import serial
import time

class Ping1D(object):
    def __init__(self, deviceName, baudrate=115200):
        if deviceName is None:
            print("Device name is required")
            return

        try:
            print("Opening %s at %d bps" % (deviceName, baudrate))

            ## Serial object for device communication
            self.iodev = serial.Serial(deviceName, baudrate)
            self.iodev.timeout = 1

        except Exception as e:
            print("Failed to open the given serial port")
            print("\t", e)
            exit(1)

        ## A helper class to take care of decoding the input stream
        self.parser = PingMessage.PingParser()

        ## device id of this Ping1D object, used for dst_device_id in outgoing messages
        self.my_id = 255

    ## Consume rx buffer data until a new message is successfully decoded
    # @return A new PingMessage: as soon as a message is parsed (there may be data remaining in the buffer to be parsed, thus requiring subsequent calls to read())
    # @return None: if the buffer is empty and no message has been parsed
    def read(self):
        while(self.iodev.in_waiting):
            b = self.iodev.read()

            if self.parser.parseByte(ord(b)) == PingMessage.PingParser.NEW_MESSAGE:
                self.handleMessage(self.parser.rxMsg)
                return self.parser.rxMsg
        return None

    ## Write data to device
    def write(self, data):
        return self.iodev.write(data)

    ## Make sure there is a device on the line and read some initial data
    # Return True if the device replies with expected data
    # Return False otherwise
    def initialize(self):
        if self.request(PingMessage.PING1D_VOLTAGE_5) is None:
            return False
        return True

    ## Request the given message ID
    # Return response if it is rxed within timeout period, None otherwise
    # TODO handle nack to exit without blocking
    def request(self, m_id, timeout=0.35):
        msg = PingMessage.PingMessage()
        msg.request_id = m_id
        msg.packMsgData()
        self.write(msg.msgData)
        return self.waitReply(m_id, timeout)

    ## Wait for the device to send a message with the desired message_id for timeout s
    # Return True if a valid message is received from the device with the desired message_id before the timeout period expires
    # Return False otherwise
    def waitReply(self, message_id, timeout=0.5):
        tstart = time.time()
        while(time.time() < tstart + timeout):
            msg = self.read()
            if msg is not None:
                if msg.message_id == message_id:
                    return msg
        return None

    ## Handle an incoming messge from the device
    # Extract message fields into self attributes
    def handleMessage(self, msg):
        if msg.message_id in PingMessage.payloadDict:
            for attr in PingMessage.payloadDict[msg.message_id]["field_names"]:
                setattr(self, attr, getattr(msg, attr))
        else:
            print("Unrecognized message: %d", msg)

    ## Dump object into string representation
    def __repr__(self):
        representation = "---------------------------------------------------------\n~Ping1D Object~"

        attrs = vars(self)
        for attr in sorted(attrs):
            try:
                if attr != 'iodev':
                    representation += "\n  - " + attr + "(hex): " + str([hex(ord(item)) for item in getattr(self, attr)])
                if attr != 'data':
                    representation += "\n  - " + attr + "(string): " + str(getattr(self, attr))
            except:
                representation += "\n  - " + attr + ": " + str(getattr(self, attr))
        return representation

    # Access Methods
    ################
    # Request a message from the device
    # If there is no reply return None, otherwise return a dictionary of the updated values

    /** Device information
    *   Returns a dictionary of the reply payload
    *  @return device_type: Device type. 0: 1D Echosounder
    *  @return device_model: Device model. 0: Ping1D
    *  @return fw_version_major: Firmware version major number.
    *  @return fw_version_minor: Firmware version minor number.
    */
    bool get_fw_version(uint8_t* device_type = nullptr,
                      uint8_t* device_model = nullptr,
                      uint16_t* fw_version_major = nullptr,
                      uint16_t* fw_version_minor = nullptr) {

        if (!request(Ping1DNamespace::Fw_version)) {
            return false;
        }

        if (device_type) *device_type = _device_type;
        if (device_model) *device_model = _device_model;
        if (fw_version_major) *fw_version_major = _fw_version_major;
        if (fw_version_minor) *fw_version_minor = _fw_version_minor;

        return true;
}

    /** The device ID.
    *   Returns a dictionary of the reply payload
    *  @return device_id: The device ID (0-254). 255 is reserved for broadcast messages.
    */
    bool get_device_id(uint8_t* device_id = nullptr) {

        if (!request(Ping1DNamespace::Device_id)) {
            return false;
        }

        if (device_id) *device_id = _device_id;

        return true;
}

    /** The 5V rail voltage.
    *   Returns a dictionary of the reply payload
    *  @return mvolts: Units: mV; The 5V rail voltage.
    */
    bool get_voltage_5(uint16_t* mvolts = nullptr) {

        if (!request(Ping1DNamespace::Voltage_5)) {
            return false;
        }

        if (mvolts) *mvolts = _mvolts;

        return true;
}

    /** The speed of sound used for distance calculations.
    *   Returns a dictionary of the reply payload
    *  @return speed_of_sound: Units: mm/s; The speed of sound in the measurement medium. ~1,500,000 mm/s for water.
    */
    bool get_speed_of_sound(uint32_t* speed_of_sound = nullptr) {

        if (!request(Ping1DNamespace::Speed_of_sound)) {
            return false;
        }

        if (speed_of_sound) *speed_of_sound = _speed_of_sound;

        return true;
}

    /** The scan range for acoustic measurements. Measurements returned by the device will lie in the range (scan_start, scan_start + scan_length).
    *   Returns a dictionary of the reply payload
    *  @return scan_start: Units: mm; The beginning of the scan range in mm from the transducer.
    *  @return scan_length: Units: mm; The length of the scan range.
    */
    bool get_range(uint32_t* scan_start = nullptr,
                      uint32_t* scan_length = nullptr) {

        if (!request(Ping1DNamespace::Range)) {
            return false;
        }

        if (scan_start) *scan_start = _scan_start;
        if (scan_length) *scan_length = _scan_length;

        return true;
}

    /** The current operating mode of the device. Manual mode allows for manual selection of the gain and scan range.
    *   Returns a dictionary of the reply payload
    *  @return mode_auto: 0: manual mode, 1: auto mode
    */
    bool get_mode_auto(uint8_t* mode_auto = nullptr) {

        if (!request(Ping1DNamespace::Mode_auto)) {
            return false;
        }

        if (mode_auto) *mode_auto = _mode_auto;

        return true;
}

    /** The interval between acoustic measurements.
    *   Returns a dictionary of the reply payload
    *  @return ping_rate: Units: ms; The interval between acoustic measurements.
    */
    bool get_ping_rate(uint16_t* ping_rate = nullptr) {

        if (!request(Ping1DNamespace::Ping_rate)) {
            return false;
        }

        if (ping_rate) *ping_rate = _ping_rate;

        return true;
}

    /** The current gain setting.
    *   Returns a dictionary of the reply payload
    *  @return gain_index: 0: 0.6dB, 1: 1.8dB, 2: 5.5dB, 3: 12.9dB, 4: 30.2dB, 5: 66.1dB, 6: 144dB
    */
    bool get_gain_index(uint32_t* gain_index = nullptr) {

        if (!request(Ping1DNamespace::Gain_index)) {
            return false;
        }

        if (gain_index) *gain_index = _gain_index;

        return true;
}

    /** The duration of the acoustic activation/transmission.
    *   Returns a dictionary of the reply payload
    *  @return pulse_usec: Units: microseconds; Acoustic pulse duration.
    */
    bool get_pulse_usec(uint16_t* pulse_usec = nullptr) {

        if (!request(Ping1DNamespace::Pulse_usec)) {
            return false;
        }

        if (pulse_usec) *pulse_usec = _pulse_usec;

        return true;
}

    /** General information.
    *   Returns a dictionary of the reply payload
    *  @return fw_version_major: Firmware major version.
    *  @return fw_version_minor: Firmware minor version.
    *  @return mvolts: Units: mV; Device supply voltage.
    *  @return ping_rate: Units: ms; The interval between acoustic measurements.
    *  @return gain_index: The current gain setting. 0: 0.6dB, 1: 1.8dB, 2: 5.5dB, 3: 12.9dB, 4: 30.2dB, 5: 66.1dB, 6: 144dB
    *  @return mode_auto: The current operating mode of the device. 0: manual mode, 1: auto mode
    */
    bool get_general_info(uint16_t* fw_version_major = nullptr,
                      uint16_t* fw_version_minor = nullptr,
                      uint16_t* mvolts = nullptr,
                      uint16_t* ping_rate = nullptr,
                      uint8_t* gain_index = nullptr,
                      uint8_t* mode_auto = nullptr) {

        if (!request(Ping1DNamespace::General_info)) {
            return false;
        }

        if (fw_version_major) *fw_version_major = _fw_version_major;
        if (fw_version_minor) *fw_version_minor = _fw_version_minor;
        if (mvolts) *mvolts = _mvolts;
        if (ping_rate) *ping_rate = _ping_rate;
        if (gain_index) *gain_index = _gain_index;
        if (mode_auto) *mode_auto = _mode_auto;

        return true;
}

    /** The distance to target with confidence estimate.
    *   Returns a dictionary of the reply payload
    *  @return distance: Units: mm; Distance to the target.
    *  @return confidence: Units: %; Confidence in the distance measurement.
    */
    bool get_distance_simple(uint32_t* distance = nullptr,
                      uint8_t* confidence = nullptr) {

        if (!request(Ping1DNamespace::Distance_simple)) {
            return false;
        }

        if (distance) *distance = _distance;
        if (confidence) *confidence = _confidence;

        return true;
}

    /** 
    *   Returns a dictionary of the reply payload
    *  @return distance: Units: mm; The current return distance determined for the most recent acoustic measurement.
    *  @return confidence: Units: %; Confidence in the most recent range measurement.
    *  @return pulse_usec: Units: us; The acoustic pulse length during acoustic transmission/activation.
    *  @return ping_number: The pulse/measurement count since boot.
    *  @return scan_start: Units: mm; The beginning of the scan region in mm from the transducer.
    *  @return scan_length: Units: mm; The length of the scan region.
    *  @return gain_index: The current gain setting. 0: 0.6dB, 1: 1.8dB, 2: 5.5dB, 3: 12.9dB, 4: 30.2dB, 5: 66.1dB, 6: 144dB
    */
    bool get_distance(uint32_t* distance = nullptr,
                      uint16_t* confidence = nullptr,
                      uint16_t* pulse_usec = nullptr,
                      uint32_t* ping_number = nullptr,
                      uint32_t* scan_start = nullptr,
                      uint32_t* scan_length = nullptr,
                      uint32_t* gain_index = nullptr) {

        if (!request(Ping1DNamespace::Distance)) {
            return false;
        }

        if (distance) *distance = _distance;
        if (confidence) *confidence = _confidence;
        if (pulse_usec) *pulse_usec = _pulse_usec;
        if (ping_number) *ping_number = _ping_number;
        if (scan_start) *scan_start = _scan_start;
        if (scan_length) *scan_length = _scan_length;
        if (gain_index) *gain_index = _gain_index;

        return true;
}

    /** Temperature of the device cpu.
    *   Returns a dictionary of the reply payload
    *  @return temp: Units: cC; The temperature in centi-degrees Centigrade (100 * degrees C).
    */
    bool get_processor_temperature(uint16_t* temp = nullptr) {

        if (!request(Ping1DNamespace::Processor_temperature)) {
            return false;
        }

        if (temp) *temp = _temp;

        return true;
}

    /** Temperature of the on-board thermistor.
    *   Returns a dictionary of the reply payload
    *  @return temp: Units: cC; The temperature in centi-degrees Centigrade (100 * degrees C).
    */
    bool get_pcb_temperature(uint16_t* temp = nullptr) {

        if (!request(Ping1DNamespace::Pcb_temperature)) {
            return false;
        }

        if (temp) *temp = _temp;

        return true;
}

    /** A profile produced from a single acoustic measurement. The data returned is an array of response strength at even intervals across the scan region. The scan region is defined as the region between <scan_start> and <scan_start + scan_length> millimeters away from the transducer. A distance measurement to the target is also provided.
    *   Returns a dictionary of the reply payload
    *  @return distance: Units: mm; The current return distance determined for the most recent acoustic measurement.
    *  @return confidence: Units: %; Confidence in the most recent range measurement.
    *  @return pulse_usec: Units: us; The acoustic pulse length during acoustic transmission/activation.
    *  @return ping_number: The pulse/measurement count since boot.
    *  @return scan_start: Units: mm; The beginning of the scan region in mm from the transducer.
    *  @return scan_length: Units: mm; The length of the scan region.
    *  @return gain_index: The current gain setting. 0: 0.6dB, 1: 1.8dB, 2: 5.5dB, 3: 12.9dB, 4: 30.2dB, 5: 66.1dB, 6: 144dB
    *  @return num_points: The number of data points for the profile. (The length of the proceeding array)
    *  @return data: An array of return strength measurements taken at regular intervals across the scan region.
    */
    bool get_profile(uint32_t* distance = nullptr,
                      uint16_t* confidence = nullptr,
                      uint16_t* pulse_usec = nullptr,
                      uint32_t* ping_number = nullptr,
                      uint32_t* scan_start = nullptr,
                      uint32_t* scan_length = nullptr,
                      uint32_t* gain_index = nullptr,
                      uint16_t* num_points = nullptr,
                      uint8_t* data = nullptr) {

        if (!request(Ping1DNamespace::Profile)) {
            return false;
        }

        if (distance) *distance = _distance;
        if (confidence) *confidence = _confidence;
        if (pulse_usec) *pulse_usec = _pulse_usec;
        if (ping_number) *ping_number = _ping_number;
        if (scan_start) *scan_start = _scan_start;
        if (scan_length) *scan_length = _scan_length;
        if (gain_index) *gain_index = _gain_index;
        if (num_points) *num_points = _num_points;
        if (data) *data = _data;

        return true;
}

    /** The protocol version
    *   Returns a dictionary of the reply payload
    *  @return protocol_version: 
    */
    bool get_protocol_version(uint32_t* protocol_version = nullptr) {

        if (!request(Ping1DNamespace::Protocol_version)) {
            return false;
        }

        if (protocol_version) *protocol_version = _protocol_version;

        return true;
}

    # Control Methods
    ###################
    # Write a new control, and read the values back from the device
    # If verify is true, fail if the values read back from the device do not match the controls that were written
    # Return True on success
    # Return False on failure to read values back or on verification failure

    /** Set the device ID.
    *  @param device_id - Device ID (0-254). 255 is reserved for broadcast messages.
    */
    void set_device_id(device_id, verify=True) {
        ping_msg_ping1D_set_device_id m;
        m.set_device_id(device_id);
        m.updateChecksum();
        self.write(m.msgData);
        if (!request(Ping1DNamespace::Device_id)) {
            return false;
        }
        # Read back the data and check that changes have been applied
        if (verify
              && self.device_id != device_id
              || false) {
            return false;
        return true; # success
     }

    /** Set the scan range for acoustic measurements.
    *  @param scan_start - Units: mm; 
    *  @param scan_length - Units: mm; The length of the scan range.
    */
    void set_range(scan_start, scan_length, verify=True) {
        ping_msg_ping1D_set_range m;
        m.set_scan_start(scan_start);
        m.set_scan_length(scan_length);
        m.updateChecksum();
        self.write(m.msgData);
        if (!request(Ping1DNamespace::Range)) {
            return false;
        }
        # Read back the data and check that changes have been applied
        if (verify
              && self.scan_start != scan_start
              || self.scan_length != scan_length
              || false) {
            return false;
        return true; # success
     }

    /** Set the speed of sound used for distance calculations.
    *  @param speed_of_sound - Units: mm/s; The speed of sound in the measurement medium. ~1,500,000 mm/s for water.
    */
    void set_speed_of_sound(speed_of_sound, verify=True) {
        ping_msg_ping1D_set_speed_of_sound m;
        m.set_speed_of_sound(speed_of_sound);
        m.updateChecksum();
        self.write(m.msgData);
        if (!request(Ping1DNamespace::Speed_of_sound)) {
            return false;
        }
        # Read back the data and check that changes have been applied
        if (verify
              && self.speed_of_sound != speed_of_sound
              || false) {
            return false;
        return true; # success
     }

    /** Set automatic or manual mode. Manual mode allows for manual selection of the gain and scan range.
    *  @param mode_auto - 0: manual mode. 1: auto mode.
    */
    void set_mode_auto(mode_auto, verify=True) {
        ping_msg_ping1D_set_mode_auto m;
        m.set_mode_auto(mode_auto);
        m.updateChecksum();
        self.write(m.msgData);
        if (!request(Ping1DNamespace::Mode_auto)) {
            return false;
        }
        # Read back the data and check that changes have been applied
        if (verify
              && self.mode_auto != mode_auto
              || false) {
            return false;
        return true; # success
     }

    /** The interval between acoustic measurements.
    *  @param ping_rate - Units: ms; The interval between acoustic measurements.
    */
    void set_ping_rate(ping_rate, verify=True) {
        ping_msg_ping1D_set_ping_rate m;
        m.set_ping_rate(ping_rate);
        m.updateChecksum();
        self.write(m.msgData);
        if (!request(Ping1DNamespace::Ping_rate)) {
            return false;
        }
        # Read back the data and check that changes have been applied
        if (verify
              && self.ping_rate != ping_rate
              || false) {
            return false;
        return true; # success
     }

    /** Set the current gain selection.
    *  @param gain_index - 0: 0.6dB, 1: 1.8dB, 2: 5.5dB, 3: 12.9dB, 4: 30.2dB, 5: 66.1dB, 6: 144dB
    */
    void set_gain_index(gain_index, verify=True) {
        ping_msg_ping1D_set_gain_index m;
        m.set_gain_index(gain_index);
        m.updateChecksum();
        self.write(m.msgData);
        if (!request(Ping1DNamespace::Gain_index)) {
            return false;
        }
        # Read back the data and check that changes have been applied
        if (verify
              && self.gain_index != gain_index
              || false) {
            return false;
        return true; # success
     }

    /** Enable or disable acoustic measurements.
    *  @param enable - 0: Disable, 1: Enable.
    */
    void set_ping_enable(enable, verify=True) {
        ping_msg_ping1D_set_ping_enable m;
        m.set_enable(enable);
        m.updateChecksum();
        self.write(m.msgData);
        if (!request(Ping1DNamespace::Ping_enable)) {
            return false;
        }
        # Read back the data and check that changes have been applied
        if (verify
              && self.enable != enable
              || false) {
            return false;
        return true; # success
     }

